<script lang="ts" setup>
import { onBeforeMount, ref } from "vue";
import { useRoute, useRouter } from "vue-router";
import { validateEmailConfirmationToken } from "@api/User";
import {
  CurrentUser,
  setLoggedInUserCreds,
  setLoggedInUserData,
  urlNormalisedCurrentGroupName,
  UserGroups,
  userIsLoggedIn,
} from "@models/LoggedInUser";
import type { ErrorResult } from "@api/types";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore
import { HttpStatusCode } from "@typedefs/api/consts.ts";

const checkingValidateEmailToken = ref(false);
const validateToken = ref("");
const isValidValidateToken = ref(false);
const validateError = ref<ErrorResult | null>(null);
const router = useRouter();
const { params } = useRoute();

const testToken = ref("");

onBeforeMount(async () => {
  // Get an email confirmation token for testing.
  // const tokenResponse = await debugGetEmailConfirmationToken("admin@email.com");
  // if (tokenResponse.success && tokenResponse.status === HttpStatusCode.Ok) {
  //   testToken.value = tokenResponse.result.token.replace(/\./g, ":");
  // }

  // Get the token, and sent it to the backend.
  const alreadyValidated =
    userIsLoggedIn.value && CurrentUser.value?.emailConfirmed;
  if (params.token && !alreadyValidated) {
    checkingValidateEmailToken.value = true;
    if (Array.isArray(params.token) && params.token.length) {
      validateToken.value = (params.token.shift() as string).replace(/:/g, ".");
    } else if (typeof params.token === "string") {
      validateToken.value = params.token.replace(/:/g, ".");
    }

    // FIXME - check it's a valid token payload locally.

    const validateTokenResponse = await validateEmailConfirmationToken(
      validateToken.value
    );
    if (!validateTokenResponse.success) {
      if (validateTokenResponse.status === HttpStatusCode.AuthorizationError) {
        // await router.push({
        //   path: "/",
        // });
      } else {
        // Grab the error.
        isValidValidateToken.value = false;
        validateError.value = validateTokenResponse.result;
      }
    } else {
      isValidValidateToken.value = true;
      const { userData, token, refreshToken, signOutUser } =
        validateTokenResponse.result;
      if (signOutUser) {
        await router.push({ name: "sign-out" });
        return;
      }
      setLoggedInUserData({
        ...userData,
      });
      setLoggedInUserCreds({
        apiToken: token,
        refreshToken,
        refreshingToken: false,
      });

      console.warn("Redirecting to dashboard");
      // NOTE: Should redirect to "setup" if user has no groups
      if (UserGroups.value?.length) {
        await router.push({
          name: "dashboard",
          params: {
            groupName: urlNormalisedCurrentGroupName.value,
          },
        });
      } else {
        await router.push({
          name: "setup",
        });
      }
    }
    checkingValidateEmailToken.value = false;
  } else {
    if (userIsLoggedIn.value) {
      if (UserGroups.value?.length) {
        await router.push({
          name: "dashboard",
          params: {
            groupName: urlNormalisedCurrentGroupName.value,
          },
        });
      } else {
        await router.push({
          name: "setup",
        });
      }
    } else {
      // No token supplied, redirect to sign-in
      await router.push({
        name: "sign-in",
      });
    }
  }
});
</script>
<template>
  <h1 v-if="checkingValidateEmailToken">
    <span class="spinner-border-sm spinner-border"></span> Confirming your email
  </h1>
  <div v-else-if="!isValidValidateToken">
    {{ validateError }}
  </div>
  <div v-else>
    <p>{{ testToken.replace(/\./g, ":") }}</p>
  </div>
</template>
